<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.7.4" />
<title>otp API documentation</title>
<meta name="description" content="Used to generate 🙊 one-time pads 🤐 exclusively in emojis …" />
<link href='https://cdnjs.cloudflare.com/ajax/libs/normalize/8.0.0/normalize.min.css' rel='stylesheet'>
<link href='https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/8.0.0/sanitize.min.css' rel='stylesheet'>
<link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/github.min.css" rel="stylesheet">
<style>.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{font-weight:bold}#index h4 + ul{margin-bottom:.6em}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>otp</code></h1>
</header>
<section id="section-intro">
<p>Used to generate 🙊 one-time pads 🤐 exclusively in emojis.</p>
<p>Also has functions for 🔒'ing and 🔓'ing text with the one time pads.</p>
<h2 id="variables">📦Variables</h2>
<p>chipher_chars : (list)
The list of emojis useable (comes from otp_emojis module)</p>
<h2 id="notes">📝Notes</h2>
<pre><code>- 🚫 DON'T USE THIS IN PRODUCTION 🚫 I created this project to help better
   understand my security course in 🏫.
</code></pre>
<h2 id="references">👩‍🏫References</h2>
<p>One Time Pad explanations:
- <a href="https://searchsecurity.techtarget.com/definition/one-time-pad">https://searchsecurity.techtarget.com/definition/one-time-pad</a>
- <a href="http://users.telenet.be/d.rijmenants/en/onetimepad.htm">http://users.telenet.be/d.rijmenants/en/onetimepad.htm</a>
- <a href="https://www.cryptomuseum.com/crypto/otp/index.htm">https://www.cryptomuseum.com/crypto/otp/index.htm</a>
- <a href="https://medium.com/blockgeeks-blog/cryptography-for-dummies-part-4-the-one-time-pad-7711438c9b8a">https://medium.com/blockgeeks-blog/cryptography-for-dummies-part-4-the-one-time-pad-7711438c9b8a</a></p>
<h2 id="examples">🤷Examples</h2>
<p>Encrypting 'Do not go gentle into that good night' by Dylan Thomas</p>
<pre><code>text = '''Do not go gentle into that good night,
Old age should burn and rave at close of day;
Rage, rage against the dying of the light.

Though wise men at their end know dark is right,
Because their words had forked no lightning they
Do not go gentle into that good night.

Good men, the last wave by, crying how bright
Their frail deeds might have danced in a green bay,
Rage, rage against the dying of the light.

Wild men who caught and sang the sun in flight,
And learn, too late, they grieved it on its way,
Do not go gentle into that good night.

Grave men, near death, who see with blinding sight
Blind eyes could blaze like meteors and be gay,
Rage, rage against the dying of the light.

And you, my father, there on the sad height,
Curse, bless, me now with your fierce tears, I pray.
Do not go gentle into that good night.
Rage, rage against the dying of the light.'''

ciphertext, pad = encrypt(text, pad_path='./pad.txt', ciphertext_path='./ciphertext.txt')

decrypt(ciphertext, pad, text_path='./decrypted_text.txt')
</code></pre>
<h2 id="todo">📋TODO</h2>
<ul>
<li>CLI</li>
<li>Write tests</li>
<li>More emojis</li>
</ul>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;Used to generate 🙊 one-time pads 🤐 exclusively in emojis.

Also has functions for 🔒&#39;ing and 🔓&#39;ing text with the one time pads.

📦Variables
------------
chipher_chars : (list)
    The list of emojis useable (comes from otp_emojis module)

📝Notes
--------
    - 🚫 DON&#39;T USE THIS IN PRODUCTION 🚫 I created this project to help better
       understand my security course in 🏫.

👩‍🏫References
-------------
One Time Pad explanations:
    - https://searchsecurity.techtarget.com/definition/one-time-pad
    - http://users.telenet.be/d.rijmenants/en/onetimepad.htm
    - https://www.cryptomuseum.com/crypto/otp/index.htm
    - https://medium.com/blockgeeks-blog/cryptography-for-dummies-part-4-the-one-time-pad-7711438c9b8a

🤷Examples
-----------
Encrypting &#39;Do not go gentle into that good night&#39; by Dylan Thomas

```
text = &#39;&#39;&#39;Do not go gentle into that good night,
Old age should burn and rave at close of day;
Rage, rage against the dying of the light.

Though wise men at their end know dark is right,
Because their words had forked no lightning they
Do not go gentle into that good night.

Good men, the last wave by, crying how bright
Their frail deeds might have danced in a green bay,
Rage, rage against the dying of the light.

Wild men who caught and sang the sun in flight,
And learn, too late, they grieved it on its way,
Do not go gentle into that good night.

Grave men, near death, who see with blinding sight
Blind eyes could blaze like meteors and be gay,
Rage, rage against the dying of the light.

And you, my father, there on the sad height,
Curse, bless, me now with your fierce tears, I pray.
Do not go gentle into that good night.
Rage, rage against the dying of the light.&#39;&#39;&#39;

ciphertext, pad = encrypt(text, pad_path=&#39;./pad.txt&#39;, ciphertext_path=&#39;./ciphertext.txt&#39;)

decrypt(ciphertext, pad, text_path=&#39;./decrypted_text.txt&#39;)
```

📋TODO
------
- CLI
- Write tests
- More emojis
&#34;&#34;&#34;

# Standard lib dependencies
import logging                  # Used to log (obviously)
from random import choice       # Used to choose each emoji per character
from typing import Generator    # Used to typehint generator returns

# Internal Dependencies
from otp_emojis import cipher_chars  # The list of useable emojis for otp generation

usage = &#34;&#34;&#34; &#34;&#34;&#34;

def generate_otp(length:int) -&gt; Generator:
    &#34;&#34;&#34;Generates a one time pad of emojis based on input length.

    Parameters
    ----------
    length:(int)
        The amount of random emoji&#39;s to generate.
        
    Yields
    ------
    str:
        The next character in the one time pad

    Examples
    --------
    Generating a 10 character otp
    ```
    from otp import generate_otp

    otp = generate_otp(10)

    for character in otp:   # Iterate through resulting generator
        print(character)    # Prints: 🙏🧗🧛👨‍🎤🎩🥯🧛🙄🏺🧞
    ```
    &#34;&#34;&#34;
    for digit in range(length):
        yield choice(cipher_chars)


def encrypt(input_text:str, pad:bool=False, pad_path:str = False, ciphertext_path:str = False) -&gt; tuple:
    &#34;&#34;&#34;Encrypts 🔒 text using provided pad, or generates one of the same length.

    Parameters
    ----------
    input_text:(str)
        The text you would like to encrypt.

    pad:(bool|str)
        If pad is specified it will be used to encrypt 
        if left False it will be generated for you.

    pad_path:(bool|str)
        If specified then it will be the path the pad is
        written to.

    ciphertext_path:(bool|str)
        If specified then it will be the path the ciphertext
        is written to.
        
    Returns
    ------
    tuple[str,str]:
        The ciphertext, and the onetime pad

    Examples
    --------
    Encrypting a 1984 (George Orwell) quote and saving
    the resulting ciphertext and path to files.
    ```
    from otp import encrypt

    text = &#39;Who controls the past controls the future. Who controls the present controls the past.&#39;

    # Creates ciphertext and pad and saves them in current directory as pad.txt and ciphertext.txt respectively
    ciphertext, pad = encrypt(text, pad_path=&#39;./pad.txt&#39;, ciphertext_path=&#39;./ciphertext.txt&#39;)
    ```
    &#34;&#34;&#34;
    print(&#34;🔒 Encrypting Text 🔒&#34;)

    logging.debug(f&#34;input_text = {input_text}&#34;)
    logging.debug(f&#34;pad={pad}&#34;)
    logging.debug(f&#34;pad_path={pad_path}&#34;)
    logging.debug(f&#34;ciphertext_path={ciphertext_path}&#34;)

    if not pad:
        pad = &#34;&#34;
        for character in generate_otp(len(input_text)):
            pad += character

    logging.debug(f&#34;pad={pad}&#34;)
    ciphertext = &#34;&#34;
    for character in zip(input_text, pad):
        

        logging.debug(f&#34;Character= {character[0]} {character[1]}&#34;)
        shifted_value = &#34;&#34;
        
        logging.debug(f&#34;{ord(character[0])} ^ {ord(character[1])}&#34;)
        shifted_value +=  str(ord(character[0]) ^ ord(character[1]))

        ciphertext += (shifted_value) + &#34;‎&#34; # Delimit ciphertext by 0em spaces and append

    ciphertext = ciphertext[0:-1]
    if pad_path:
        with open(pad_path, &#34;wb&#34;) as otp_file:
            otp_file.write(pad.encode(&#34;utf-8&#34;))
        logging.info(f&#34;One-time-pad text written to: {pad_path}&#34;)

    if ciphertext_path:
        with open(ciphertext_path, &#34;wb&#34;) as encrypted_message:
            encrypted_message.write(ciphertext.encode(&#34;utf-8&#34;))
        logging.info(f&#34;Encrypted text written to: {ciphertext_path}&#34;)

    return ciphertext, pad

def decrypt(cipher_text:str, pad:str, text_path:str = False) -&gt; str:
    &#34;&#34;&#34;Decrypts 🔓 text using provided pad.

    Parameters
    ----------
    cipher_text:(str)
        The text you would like to decrypt.

    pad:(str)
        The pad that corresponds with the ciphertext.

    text_path:(bool|str)
        If specified then it will be the path the decrypted
        text is written to.
        
    Returns
    ------
    str:
        The decrypted text

    Examples
    --------
    Encrypting some text from files found in the encrypt() example.
    ```
    from otp import decrypt

    pad = &#39;&#39;

    ciphertext = &#39;&#39;

    with open(&#39;pad.txt&#39;) as pad_file:
        pad = pad_file.read()

    with open(&#39;ciphertext.txt&#39;) as ciphertext_file:
        ciphertext = ciphertext_file.read()

    print( decrypt(ciphertext, pad) ) # Prints: &#39;Who controls the past controls the future. Who controls the present controls the past.&#39;
    ```
    &#34;&#34;&#34;
    cipher_text = cipher_text.split(&#34;‎&#34;) # Split ciphertext by 0em spaces

    print(&#34;👀 Decrypting text 👀&#34;)

    plaintext = &#34;&#34;

    logging.debug(f&#34;cipher_text={cipher_text}&#34;)
    logging.debug(f&#34;pad={pad}&#34;)

    for character in zip(cipher_text, pad): # Use pad to decrypt each character
        logging.debug(f&#34;Character= {character[0]} {character[1]}&#34;)

        decrypted_value = &#34;&#34;
        logging.debug(f&#34;{character[0]} ^ {character[1]}&#34;)

        decrypted_value +=  chr(int(character[0]) ^ ord(character[1]))
        plaintext += decrypted_value

    if text_path:
        with open(text_path, &#34;wb&#34;) as encrypted_message:
            encrypted_message.write(plaintext.encode(&#34;utf-8&#34;))
        logging.info(f&#34;Decrypted text written to: {text_path}&#34;)

    return plaintext

def main():
    &#34;&#34;&#34;TODO: Primary otp script entrypoint&#34;&#34;&#34;</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="otp.decrypt"><code class="name flex">
<span>def <span class="ident">decrypt</span></span>(<span>cipher_text, pad, text_path=False)</span>
</code></dt>
<dd>
<section class="desc"><p>Decrypts 🔓 text using provided pad.</p>
<h2 id="parameters">Parameters</h2>
<p>cipher_text:(str)
The text you would like to decrypt.</p>
<p>pad:(str)
The pad that corresponds with the ciphertext.</p>
<p>text_path:(bool|str)
If specified then it will be the path the decrypted
text is written to.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>str</code>:</dt>
<dd>The decrypted text</dd>
</dl>
<h2 id="examples">Examples</h2>
<p>Encrypting some text from files found in the encrypt() example.</p>
<pre><code>from otp import decrypt

pad = ''

ciphertext = ''

with open('pad.txt') as pad_file:
    pad = pad_file.read()

with open('ciphertext.txt') as ciphertext_file:
    ciphertext = ciphertext_file.read()

print( decrypt(ciphertext, pad) ) # Prints: 'Who controls the past controls the future. Who controls the present controls the past.'
</code></pre></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def decrypt(cipher_text:str, pad:str, text_path:str = False) -&gt; str:
    &#34;&#34;&#34;Decrypts 🔓 text using provided pad.

    Parameters
    ----------
    cipher_text:(str)
        The text you would like to decrypt.

    pad:(str)
        The pad that corresponds with the ciphertext.

    text_path:(bool|str)
        If specified then it will be the path the decrypted
        text is written to.
        
    Returns
    ------
    str:
        The decrypted text

    Examples
    --------
    Encrypting some text from files found in the encrypt() example.
    ```
    from otp import decrypt

    pad = &#39;&#39;

    ciphertext = &#39;&#39;

    with open(&#39;pad.txt&#39;) as pad_file:
        pad = pad_file.read()

    with open(&#39;ciphertext.txt&#39;) as ciphertext_file:
        ciphertext = ciphertext_file.read()

    print( decrypt(ciphertext, pad) ) # Prints: &#39;Who controls the past controls the future. Who controls the present controls the past.&#39;
    ```
    &#34;&#34;&#34;
    cipher_text = cipher_text.split(&#34;‎&#34;) # Split ciphertext by 0em spaces

    print(&#34;👀 Decrypting text 👀&#34;)

    plaintext = &#34;&#34;

    logging.debug(f&#34;cipher_text={cipher_text}&#34;)
    logging.debug(f&#34;pad={pad}&#34;)

    for character in zip(cipher_text, pad): # Use pad to decrypt each character
        logging.debug(f&#34;Character= {character[0]} {character[1]}&#34;)

        decrypted_value = &#34;&#34;
        logging.debug(f&#34;{character[0]} ^ {character[1]}&#34;)

        decrypted_value +=  chr(int(character[0]) ^ ord(character[1]))
        plaintext += decrypted_value

    if text_path:
        with open(text_path, &#34;wb&#34;) as encrypted_message:
            encrypted_message.write(plaintext.encode(&#34;utf-8&#34;))
        logging.info(f&#34;Decrypted text written to: {text_path}&#34;)

    return plaintext</code></pre>
</details>
</dd>
<dt id="otp.encrypt"><code class="name flex">
<span>def <span class="ident">encrypt</span></span>(<span>input_text, pad=False, pad_path=False, ciphertext_path=False)</span>
</code></dt>
<dd>
<section class="desc"><p>Encrypts 🔒 text using provided pad, or generates one of the same length.</p>
<h2 id="parameters">Parameters</h2>
<p>input_text:(str)
The text you would like to encrypt.</p>
<p>pad:(bool|str)
If pad is specified it will be used to encrypt
if left False it will be generated for you.</p>
<p>pad_path:(bool|str)
If specified then it will be the path the pad is
written to.</p>
<p>ciphertext_path:(bool|str)
If specified then it will be the path the ciphertext
is written to.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>tuple</code>[<code>str</code>,<code>str</code>]:</dt>
<dd>The ciphertext, and the onetime pad</dd>
</dl>
<h2 id="examples">Examples</h2>
<p>Encrypting a 1984 (George Orwell) quote and saving
the resulting ciphertext and path to files.</p>
<pre><code>from otp import encrypt

text = 'Who controls the past controls the future. Who controls the present controls the past.'

# Creates ciphertext and pad and saves them in current directory as pad.txt and ciphertext.txt respectively
ciphertext, pad = encrypt(text, pad_path='./pad.txt', ciphertext_path='./ciphertext.txt')
</code></pre></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def encrypt(input_text:str, pad:bool=False, pad_path:str = False, ciphertext_path:str = False) -&gt; tuple:
    &#34;&#34;&#34;Encrypts 🔒 text using provided pad, or generates one of the same length.

    Parameters
    ----------
    input_text:(str)
        The text you would like to encrypt.

    pad:(bool|str)
        If pad is specified it will be used to encrypt 
        if left False it will be generated for you.

    pad_path:(bool|str)
        If specified then it will be the path the pad is
        written to.

    ciphertext_path:(bool|str)
        If specified then it will be the path the ciphertext
        is written to.
        
    Returns
    ------
    tuple[str,str]:
        The ciphertext, and the onetime pad

    Examples
    --------
    Encrypting a 1984 (George Orwell) quote and saving
    the resulting ciphertext and path to files.
    ```
    from otp import encrypt

    text = &#39;Who controls the past controls the future. Who controls the present controls the past.&#39;

    # Creates ciphertext and pad and saves them in current directory as pad.txt and ciphertext.txt respectively
    ciphertext, pad = encrypt(text, pad_path=&#39;./pad.txt&#39;, ciphertext_path=&#39;./ciphertext.txt&#39;)
    ```
    &#34;&#34;&#34;
    print(&#34;🔒 Encrypting Text 🔒&#34;)

    logging.debug(f&#34;input_text = {input_text}&#34;)
    logging.debug(f&#34;pad={pad}&#34;)
    logging.debug(f&#34;pad_path={pad_path}&#34;)
    logging.debug(f&#34;ciphertext_path={ciphertext_path}&#34;)

    if not pad:
        pad = &#34;&#34;
        for character in generate_otp(len(input_text)):
            pad += character

    logging.debug(f&#34;pad={pad}&#34;)
    ciphertext = &#34;&#34;
    for character in zip(input_text, pad):
        

        logging.debug(f&#34;Character= {character[0]} {character[1]}&#34;)
        shifted_value = &#34;&#34;
        
        logging.debug(f&#34;{ord(character[0])} ^ {ord(character[1])}&#34;)
        shifted_value +=  str(ord(character[0]) ^ ord(character[1]))

        ciphertext += (shifted_value) + &#34;‎&#34; # Delimit ciphertext by 0em spaces and append

    ciphertext = ciphertext[0:-1]
    if pad_path:
        with open(pad_path, &#34;wb&#34;) as otp_file:
            otp_file.write(pad.encode(&#34;utf-8&#34;))
        logging.info(f&#34;One-time-pad text written to: {pad_path}&#34;)

    if ciphertext_path:
        with open(ciphertext_path, &#34;wb&#34;) as encrypted_message:
            encrypted_message.write(ciphertext.encode(&#34;utf-8&#34;))
        logging.info(f&#34;Encrypted text written to: {ciphertext_path}&#34;)

    return ciphertext, pad</code></pre>
</details>
</dd>
<dt id="otp.generate_otp"><code class="name flex">
<span>def <span class="ident">generate_otp</span></span>(<span>length)</span>
</code></dt>
<dd>
<section class="desc"><p>Generates a one time pad of emojis based on input length.</p>
<h2 id="parameters">Parameters</h2>
<p>length:(int)
The amount of random emoji's to generate.</p>
<h2 id="yields">Yields</h2>
<dl>
<dt><code>str</code>:</dt>
<dd>The next character in the one time pad</dd>
</dl>
<h2 id="examples">Examples</h2>
<p>Generating a 10 character otp</p>
<pre><code>from otp import generate_otp

otp = generate_otp(10)

for character in otp:   # Iterate through resulting generator
    print(character)    # Prints: 🙏🧗🧛👨‍🎤🎩🥯🧛🙄🏺🧞
</code></pre></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def generate_otp(length:int) -&gt; Generator:
    &#34;&#34;&#34;Generates a one time pad of emojis based on input length.

    Parameters
    ----------
    length:(int)
        The amount of random emoji&#39;s to generate.
        
    Yields
    ------
    str:
        The next character in the one time pad

    Examples
    --------
    Generating a 10 character otp
    ```
    from otp import generate_otp

    otp = generate_otp(10)

    for character in otp:   # Iterate through resulting generator
        print(character)    # Prints: 🙏🧗🧛👨‍🎤🎩🥯🧛🙄🏺🧞
    ```
    &#34;&#34;&#34;
    for digit in range(length):
        yield choice(cipher_chars)</code></pre>
</details>
</dd>
<dt id="otp.main"><code class="name flex">
<span>def <span class="ident">main</span></span>(<span>)</span>
</code></dt>
<dd>
<section class="desc"><p>TODO: Primary otp script entrypoint</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def main():
    &#34;&#34;&#34;TODO: Primary otp script entrypoint&#34;&#34;&#34;</code></pre>
</details>
</dd>
</dl>
</section>
<section>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul>
<li><a href="#variables">📦Variables</a></li>
<li><a href="#notes">📝Notes</a></li>
<li><a href="#references">👩‍🏫References</a></li>
<li><a href="#examples">🤷Examples</a></li>
<li><a href="#todo">📋TODO</a></li>
</ul>
</div>
<ul id="index">
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="otp.decrypt" href="#otp.decrypt">decrypt</a></code></li>
<li><code><a title="otp.encrypt" href="#otp.encrypt">encrypt</a></code></li>
<li><code><a title="otp.generate_otp" href="#otp.generate_otp">generate_otp</a></code></li>
<li><code><a title="otp.main" href="#otp.main">main</a></code></li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.7.4</a>.</p>
</footer>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
<script>hljs.initHighlightingOnLoad()</script>
</body>
</html>